## Defining trajectories

Trajectories are defined with the `simmer` function `trajectory()`. The `simmer` structure requires that, if a trajectory references the environment (for example recording the time of an event as an attribute with the `now(env)` function) the environment must already be defined. However, separate simulation environments need to be instantiated for separate purposes to enable modular use of submodels. For that reason, trajectories are built in so-called "factory functions", which take `env` as an argument. So an environment does have to be defined before the trajectory is built, but the code for constructing the trajectories can be reused. Given that set-up, it makes sense to also use parameters as an argument in the model, so they can straightforwardly be adjusted when constructing a new set of trajectories. The `params` argument in the factory function is a `list` of named parameters with default values, so some or all parameters can be adjusted at the point of construction of the trajectories.

## Concurrent treatments

-   Upon entering EIP, individuals are cloned and sent into the queue to seize resources for each of the component treatments
-   Upon receipt of each treatment (i.e. after resource is successfully seized and released), the receipt of that component for each service user is recorded
-   The key challenge is that, once cloned, each new clone is a completely separate entity, meaning that the receipt of a component is recorded only for the the clone, not for the original entity. It's crucial that the receipt of component is recorded for one, canonical entity so that it can be used to calculate treatment effects on the timing of acute episodes, and other outcomes, from the point of receipt.
-   `simmer` offers functionality for bringing together and destroying clones once they have completed their trajectory, using the `synchronize` function. However, this can again only take one clone, using `wait = TRUE` to select the last to arrive or `wait = FALSE` to select the first to arrive. The attributes are then only recorded for one arbitrary clone (depending on the arrival times).
-   One possible solution is to use the signalling functionality within `simmer`, i.e. the `send` and `trap` functions. In this case, no attributes are set for any clones, but clones send a signal to a primary entity who then records the receipt and updates the attribute accordingly. The challenge here is where to place the `trap` command, because receipt of a trapped signal moves any entity on from a waiting or timeout status. If the trap is "set" before the clone point, then every clone will receive the trap (good, meaning all attributes are recorded), but it will then skip the longer lasting timeouts (not good). This means the trap needs to be set in exactly one clone, where the receipt of the trap doesn't disrupt any ongoing timeout functions.
-   To do this, we construct a special trapping trajectory, which waits for the signals of receipt from each clone, records receipt as an attribute, then ensures it finishes its trajectory last, before `synchronize` with `wait = TRUE` is called.
